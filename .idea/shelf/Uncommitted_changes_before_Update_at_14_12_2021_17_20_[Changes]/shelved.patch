Index: mobs.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport math\r\nfrom constans import GRAVITAION, JUMP_SPEED, KICK_CONSTANT, SIZE_BLOCK, TIME_STOP, SPEED_Player, DELITA, SPEED_Zombie\r\n\r\n\r\ndef point_collision_x(x, y, vx, massive_slov, types_block):\r\n    drovable_block = types_block.get(massive_slov[int(y // 1)][int((x + vx) // 1)], 0)\r\n    if not drovable_block.permeability:\r\n        move_x = False\r\n    else:\r\n        move_x = True\r\n    return move_x\r\n\r\n\r\ndef point_collision_y(x, y, vy, massive_slov, types_block):\r\n    drovable_block = types_block.get(massive_slov[int((y + vy) // 1)][int(x // 1)], 0)\r\n    if not drovable_block.permeability:\r\n        move_y = False\r\n    else:\r\n        move_y = True\r\n    return move_y\r\n\r\n\r\nclass Main_person:\r\n    def __init__(self, x, y, images, screen):\r\n        self.destroy = True\r\n        self.x_dot = None\r\n        self.y_dot = None\r\n        self.x = x\r\n        self.y = y\r\n        self.vx = 0\r\n        self.vy = 0\r\n        self.size = SIZE_BLOCK\r\n        self.real_size = 45\r\n        self.an = 0\r\n        self.image_idx = 0\r\n        self.current_frame = 0\r\n        self.animation_frames = 10  # Количество кадров между сменой анимации\r\n        self.images = images\r\n        # реальный размер, меньше 37 пикселей не надо жеательно больше 40\r\n        self.otn = self.real_size / self.size\r\n        self.screen = screen\r\n        self.state = 'STAYING'  # can be STAYING/R_RUNNING/L_RUNNING/JUMPING/...\r\n        self.mouse_pressed = None\r\n        self.start_time = 0\r\n        self.life = 10\r\n        self.put = True\r\n\r\n    def update_frame_dependent(self):\r\n        self.current_frame += 1\r\n        if self.current_frame >= self.animation_frames:\r\n            self.current_frame = 0\r\n            if self.state == 'R_RUNNING':\r\n                self.image_idx = self.image_idx % 2 + 1  # 1 <-> 2\r\n            elif self.state == 'L_RUNNING':\r\n                self.image_idx = (self.image_idx + 1) % 2 + 4  # 4 <-> 5\r\n            else:\r\n                self.image_idx = 0\r\n\r\n    def input(self, event):\r\n        keys = pygame.key.get_pressed()\r\n        if keys[pygame.K_d]:\r\n            self.vx = SPEED_Player\r\n            self.state = 'R_RUNNING'\r\n        elif keys[pygame.K_a]:\r\n            self.vx = -SPEED_Player\r\n            self.state = 'L_RUNNING'\r\n        else:\r\n            self.vx = 0\r\n            self.state = 'STAYING'\r\n        if keys[pygame.K_w] and self.vy == 0:\r\n            self.vy = -JUMP_SPEED\r\n        self.vy += GRAVITAION\r\n\r\n    def control_collision(self, massive_slov, types_block):\r\n        for i in self.x + DELITA, self.x + 1 * self.otn - DELITA:\r\n            for j in self.y + DELITA, self.y + 1 * self.otn, self.y + 2 * self.otn - DELITA:\r\n                if not (point_collision_x(i, j, self.vx, massive_slov, types_block)):\r\n                    if self.vx > 0:\r\n                        self.x = round(self.x) + 1 - self.otn\r\n                    else:\r\n                        self.x = round(self.x)\r\n                    self.vx = 0\r\n                    self.put = False\r\n                    break\r\n                else:\r\n                    self.put = True\r\n        for i in self.x + DELITA, self.x + 1 * self.otn - DELITA:\r\n            for j in self.y + DELITA, self.y + 1 * self.otn, self.y + 2 * self.otn - DELITA:\r\n                if not (point_collision_y(i, j, self.vy, massive_slov, types_block)):\r\n                    if self.vy < 0:\r\n                        self.y = round(self.y)\r\n                        self.vy = 0.002\r\n                    else:\r\n                        self.y = round(self.y) + 2 * (1 - self.otn)\r\n                        self.vy = 0\r\n                    break\r\n\r\n    def control_collision_of_putting(self, massive_slov, types_block):\r\n        self.put = True\r\n        for i in self.x + DELITA, self.x + 1 * self.otn - DELITA:\r\n            for j in self.y + DELITA, self.y + 1 * self.otn, self.y + 2 * self.otn - DELITA:\r\n                if not (point_collision_x(i, j, 0, massive_slov, types_block)):\r\n                    self.put = False\r\n                    break\r\n                else:\r\n                    self.put = True\r\n        if self.put:\r\n            for i in self.x + DELITA, self.x + 1 * self.otn - DELITA:\r\n                for j in self.y + DELITA, self.y + 1 * self.otn, self.y + 2 * self.otn - DELITA:\r\n                    if not (point_collision_y(i, j, 0, massive_slov, types_block)):\r\n                        self.put = False\r\n                        break\r\n                    else:\r\n                        self.put = True\r\n\r\n    def move(self):\r\n        self.x += self.vx\r\n        self.y += self.vy\r\n\r\n    def angle(self, event, x0, y0):\r\n        if event.type == pygame.MOUSEMOTION:\r\n            if event:\r\n                self.an = math.atan2(((event.pos[1] - y0) / self.size - (self.y + self.otn)), ((\r\n                                                                                                       event.pos[\r\n                                                                                                           0] - x0) / self.size - (\r\n                                                                                                       self.x + self.otn / 2)))\r\n            else:\r\n                self.an = 0\r\n\r\n    def broke(self, massive_slov, types_block, inventory):\r\n        self.mouse_pressed = pygame.mouse.get_pressed()\r\n        if self.mouse_pressed[0]:\r\n            time_to_die = pygame.time.get_ticks()\r\n            for i in range(30):\r\n                self.x_dot = self.x + self.otn / 2 + math.cos(self.an) * i / 10\r\n                self.y_dot = self.y + self.otn + math.sin(self.an) * i / 10\r\n                if massive_slov[int(self.y_dot)][int(self.x_dot)] != 0:\r\n                    self.destroy = True\r\n                    break\r\n                else:\r\n                    self.destroy = False\r\n            if self.destroy:\r\n                breakable_block = types_block.get(massive_slov[int(self.y_dot)][int(self.x_dot)], 0)\r\n                seconds = breakable_block.durability\r\n                if time_to_die - self.start_time >= seconds * 10 ** 3 / 10:\r\n                    inventory.add_or_delete_block(massive_slov[int(self.y_dot)][int(self.x_dot)], 1)\r\n                    massive_slov[int(self.y_dot)][int(self.x_dot)] = 0\r\n                    time_to_die = pygame.time.get_ticks()\r\n                    self.start_time = pygame.time.get_ticks()\r\n\r\n    def build(self, block_in_hands, massive_slov, types_block, inventory):\r\n\r\n        if block_in_hands != 0:\r\n            for i in range(30):\r\n                self.x_dot = self.x + self.otn / 2 + math.cos(self.an) * i / 10\r\n                self.y_dot = self.y + self.otn + math.sin(self.an) * i / 10\r\n                if massive_slov[int(self.y_dot)][int(self.x_dot)] != 0:\r\n                    man_rect = pygame.Rect((self.x * 10 ** 5, self.y * 10 ** 5, self.otn * 10 ** 5, 2 * self.otn * 10 ** 5))\r\n                    block_rect = pygame.Rect((int(self.x + self.otn / 2 + math.cos(self.an) * (i - 1) / 10) * 10 ** 5,\r\n                                              int(self.y + self.otn + math.sin(self.an) * (i - 1) / 10) * 10 ** 5, 10 ** 5, 10 ** 5))\r\n                    if not man_rect.colliderect(block_rect):\r\n                        print(man_rect.topleft, block_rect.topleft)\r\n                        block_in_hands = inventory.add_or_delete_block(block_in_hands, -1)\r\n                        massive_slov[int(self.y + self.otn + math.sin(self.an) * (i - 1) / 10)][\r\n                            int(self.x + self.otn / 2 + math.cos(self.an) * (i - 1) / 10)] = block_in_hands\r\n                    break\r\n        return block_in_hands\r\n\r\n    def breath(self):\r\n        pass\r\n\r\n    def hit(self, event, massive_mobs):\r\n        if event.button == 1:\r\n            print(1)\r\n            for zombie in massive_mobs[::-1]:\r\n                if (zombie.x - self.x) ** 2 + (zombie.y - self.y) ** 2 <= 3:\r\n                    zombie.life -= 1\r\n                    if zombie.life == 0:\r\n                        massive_mobs.remove(zombie)\r\n                    break\r\n\r\n    def draw(self):\r\n        rect = self.images[self.image_idx].get_rect()\r\n        rect.topleft = self.x * self.size, self.y * self.size\r\n        self.screen.blit(self.images[self.image_idx], rect)\r\n\r\n\r\nclass Zombie(Main_person):\r\n    def __init__(self, x, y, images, screen):\r\n        super().__init__(x, y, images, screen)\r\n        self.time_tick = 0\r\n        self.sign = 1\r\n        self.image_idx = 6\r\n        self.current_frame = 0\r\n        self.animation_frames = 10  # Количество кадров между сменой анимации\r\n        self.images = images\r\n        self.life = 5\r\n\r\n    def input(self, main_hero):\r\n        if self.x - main_hero.x > 0:\r\n            self.sign = -1\r\n        elif self.x - main_hero.x < 0:\r\n            self.sign = 1\r\n        else:\r\n            self.sign = 0\r\n        if self.vx == 0:\r\n            self.time_tick += 1\r\n        if self.time_tick == TIME_STOP:\r\n            if self.vy == 0: self.vy = -JUMP_SPEED\r\n            self.time_tick = 0\r\n        self.vx = self.sign * SPEED_Zombie\r\n        self.vy += GRAVITAION\r\n\r\n    def update_frame_dependent(self):\r\n        self.current_frame += 1\r\n        if self.current_frame >= self.animation_frames:\r\n            self.current_frame = 0\r\n            if self.sign == 1:\r\n                self.image_idx = (self.image_idx + 1) % 2 + 6  # 6 <-> 7\r\n            elif self.sign == -1:\r\n                self.image_idx = (self.image_idx + 1) % 2 + 8  # 8 <-> 9\r\n                print(self.image_idx)\r\n            else:\r\n                self.image_idx = 6\r\n\r\n    def draw(self):\r\n        rect = self.images[self.image_idx].get_rect()\r\n        rect.topleft = self.x * self.size, self.y * self.size\r\n        self.screen.blit(self.images[self.image_idx], rect)\r\n\r\n    def kick(self, main_hero):\r\n        if math.sqrt((main_hero.x - self.x) ** 2 + (main_hero.y - self.y) ** 2) <= 1:\r\n            main_hero.breath()\r\n            main_hero.vx += self.sign * KICK_CONSTANT\r\n            print(\"Kick\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mobs.py b/mobs.py
--- a/mobs.py	(revision d58d48f91805cd3cde50ef159797bba8b2a09bc9)
+++ b/mobs.py	(date 1639465902786)
@@ -232,5 +232,5 @@
     def kick(self, main_hero):
         if math.sqrt((main_hero.x - self.x) ** 2 + (main_hero.y - self.y) ** 2) <= 1:
             main_hero.breath()
-            main_hero.vx += self.sign * KICK_CONSTANT
+            main_hero.vx = 3 * self.sign * KICK_CONSTANT
             print("Kick")
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import block\r\nimport mobs\r\nimport pygame\r\nimport file\r\nfrom constans import *\r\nimport Hume_screen\r\nimport pathlib\r\nimport inventoty\r\n\r\ndef veb_cam(main_screen, x_cam, y_cam):\r\n    \"\"\"\r\n    Фунция вызывающая камеру, которая рисует картинку в зависимости от положения игрока\r\n    main_screen - главный экран на котором должна быть картинка\r\n    x_cam, y_cam - положение камеры в предудущий тик\r\n    \"\"\"\r\n    size_y = len(massive_slov)\r\n    size_x = len(massive_slov[1])\r\n    speed_cam = 1  # коэфициент пропорциональности скорости\r\n    max_distant = 2 * SIZE_BLOCK  # максимальное удаление\r\n    screen = pygame.Surface((size_x * SIZE_BLOCK, size_y * SIZE_BLOCK))\r\n    main_hero.screen = screen\r\n    # отдаление от центра по X\r\n    diff_x = -main_hero.x * SIZE_BLOCK + main_screen.get_size()[0] / 2 - x_cam\r\n    # отдаление от центра по Y\r\n    diff_y = -main_hero.y * SIZE_BLOCK + main_screen.get_size()[1] / 2 - y_cam\r\n    \"Собственно движение камеры\"\r\n    if diff_x >= max_distant:\r\n        x_cam += speed_cam * diff_x / max_distant\r\n    if diff_x <= -max_distant:\r\n        x_cam += speed_cam * diff_x / max_distant\r\n    if diff_y >= max_distant:\r\n        y_cam += speed_cam * diff_y / max_distant\r\n    if diff_y <= -max_distant:\r\n        y_cam += speed_cam * diff_y / max_distant\r\n    file.draw_map(massive_slov, types_block, screen)\r\n    main_hero.draw()\r\n    for i in massive_mobs:\r\n        i.screen = screen\r\n        i.draw()\r\n    main_screen.blit(screen, (x_cam, y_cam))\r\n    return x_cam, y_cam\r\n\r\n\r\npygame.init()\r\nmain_screen = pygame.display.set_mode((1000, 800), pygame.RESIZABLE)\r\nfile_world = pathlib.Path(pathlib.Path.cwd(), \"Queen Bee-Fire-kissvk.com.wav\")\r\npygame.mixer.music.load(file_world)\r\npygame.mixer.music.play(-1)\r\ntypes_block = {}\r\nperson_images = {}\r\nblock.types(types_block, person_images)\r\nfile_world = Hume_screen.hyme_screen(main_screen)\r\nfile_inventory = open(pathlib.Path(pathlib.Path.cwd(),\r\n                      \"Saves_inventory\", \"inventory\" + file_world), 'r')\r\ninventory = inventoty.Inventory(file_inventory, main_screen)\r\nblock_in_hands = 0\r\nmassive_slov, map_types = file.load_map(types_block, file_world)\r\nsize_y = len(massive_slov)\r\nsize_x = len(massive_slov[1])\r\nscreen = pygame.Surface((size_x * SIZE_BLOCK, size_y * SIZE_BLOCK))\r\nmain_hero = mobs.Main_person(10, 2, person_images, main_screen)\r\nmassive_mobs = []\r\n\r\nmassive_mobs.append(mobs.Zombie(20, 5, person_images, main_screen))\r\nx_cam = -main_hero.x * SIZE_BLOCK + main_screen.get_size()[0] / 2\r\ny_cam = -main_hero.y * SIZE_BLOCK + main_screen.get_size()[1] / 2\r\nfinished = False\r\n\r\nclock = pygame.time.Clock()\r\ntime = 0\r\npygame.display.update()\r\nwhile not finished:\r\n    time += 1\r\n    main_screen.fill((0, 0, 0))\r\n    '''начало блока рисования'''\r\n    x_cam, y_cam = veb_cam(main_screen, x_cam, y_cam)\r\n    '''конец блока рисования'''\r\n\r\n    dt = clock.tick(FPS) / 1000  # Amount of seconds between each loop.\r\n    if time % 1000 == 0:\r\n        massive_mobs.append(mobs.Zombie(20, 5, person_images, main_screen))\r\n    for event in pygame.event.get():\r\n        main_hero.angle(event, x_cam, y_cam)\r\n        if event.type == pygame.QUIT:\r\n            finished = True\r\n        elif event.type == pygame.MOUSEBUTTONDOWN:\r\n            main_hero.start_time = pygame.time.get_ticks()\r\n            if event.button == 3:\r\n                main_hero.build(block_in_hands, massive_slov, types_block, inventory)\r\n            main_hero.hit(event, massive_mobs)\r\n        main_hero.angle(event, x_cam, y_cam)\r\n    keys = pygame.key.get_pressed()\r\n    if keys[pygame.K_e]:\r\n        block_in_hands = inventoty.inventoryfunction(main_screen, inventory,block_in_hands)\r\n\r\n    main_hero.broke(massive_slov, types_block, inventory)\r\n    main_hero.input(event=0)\r\n    main_hero.control_collision(massive_slov, types_block)\r\n    main_hero.update_frame_dependent()\r\n    \"Обработка событий связанных с зомби\"\r\n    for i in massive_mobs:\r\n        i.input(main_hero)\r\n        i.control_collision(massive_slov, types_block)\r\n        i.move()\r\n        i.update_frame_dependent()\r\n        i.kick(main_hero)\r\n    main_hero.move()\r\n    keys = pygame.key.get_pressed()\r\n    if keys[pygame.K_e]:\r\n        block_in_hands = inventoty.inventoryfunction(\r\n            main_screen, inventory, block_in_hands)\r\n    pygame.display.update()\r\n    pygame.display.flip()\r\nfile.save_map(massive_slov, file_world)\r\npygame.quit()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision d58d48f91805cd3cde50ef159797bba8b2a09bc9)
+++ b/main.py	(date 1639466071161)
@@ -92,7 +92,6 @@
     keys = pygame.key.get_pressed()
     if keys[pygame.K_e]:
         block_in_hands = inventoty.inventoryfunction(main_screen, inventory,block_in_hands)
-
     main_hero.broke(massive_slov, types_block, inventory)
     main_hero.input(event=0)
     main_hero.control_collision(massive_slov, types_block)
@@ -104,6 +103,7 @@
         i.move()
         i.update_frame_dependent()
         i.kick(main_hero)
+        main_hero.control_collision(massive_slov, types_block)
     main_hero.move()
     keys = pygame.key.get_pressed()
     if keys[pygame.K_e]:
